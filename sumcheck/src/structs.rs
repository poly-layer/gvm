use ff::PrimeField;
use goldilocks::SmallField;
use multilinear_extensions::virtual_poly::VirtualPolynomial;
use transcript::Challenge;
use serde::{Serialize, Deserialize};

/// An IOP proof is a collections of
/// - messages from prover to verifier at each round through the interactive protocol.
/// - a point that is generated by the transcript for evaluation
#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct IOPProof<F: SmallField> {
    pub point: Vec<F>,
    pub proofs: Vec<IOPProverMessage<F>>,
}

/// A message from the prover to the verifier at a given round
/// is a list of evaluations.
#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct IOPProverMessage<F: SmallField> {
    pub(crate) evaluations: Vec<F>,
}

/// Prover State of a PolyIOP.
pub struct IOPProverState<F: SmallField> {
    /// sampled randomness given by the verifier
    pub challenges: Vec<Challenge<F>>,
    /// the current round number
    pub(crate) round: usize,
    /// pointer to the virtual polynomial
    pub(crate) poly: VirtualPolynomial<F>,
    /// points with precomputed barycentric weights for extrapolating smaller
    /// degree uni-polys to `max_degree + 1` evaluations.
    pub(crate) extrapolation_aux: Vec<(Vec<F>, Vec<F>)>,
}